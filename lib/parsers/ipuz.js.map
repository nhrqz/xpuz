{"version":3,"sources":["../../src/parsers/ipuz.js"],"names":["Promise","require","max","get","isObject","reduce","Puzzle","BLOCK_VALUE","_checkDimensions","puzzle","errors","maxCellWidth","length","numRows","dimensions","width","push","height","_getClueNumber","cell","_addClue","obj","clue","_convertPuzzle","ipuz","info","title","author","copyright","publisher","difficulty","intro","grid","map","row","isBlockCell","clueNumber","backgroundShape","clues","across","down","_validatePuzzle","_parsePuzzle","resolve","reject","Error","then","join","IPUZParser","exports","module"],"mappings":"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","file":"ipuz.js","sourcesContent":["/**\n * IPUZ file parser.\n *\n * @module xpuz/parsers/ipuz\n */\n\nconst Promise         = require(\"bluebird\");\nconst max             = require(\"lodash/max\");\nconst get             = require(\"lodash/get\");\nconst isObject        = require(\"lodash/isObject\");\nconst reduce          = require(\"lodash/reduce\");\nconst Puzzle          = require(\"../puzzle\");\n\nconst BLOCK_VALUE = \"#\";\n\nfunction _checkDimensions(puzzle) {\n\tconst errors = [];\n\n\tconst maxCellWidth = max(\n\t\tpuzzle.puzzle,\n\t\t\"length\"\n\t).length;\n\n\tconst numRows = puzzle.puzzle.length;\n\n\tif (maxCellWidth > puzzle.dimensions.width) {\n\t\terrors.push(`Too many puzzle cells (${maxCellWidth}) for puzzle width (${puzzle.dimensions.width})`);\n\t}\n\n\tif (numRows > puzzle.dimensions.height) {\n\t\terrors.push(`Too many puzzle cells (${numRows}) for puzzle height (${puzzle.dimensions.height})`);\n\t}\n\n\treturn errors;\n}\n\nfunction _getClueNumber(cell) {\n\treturn isObject(cell) ?\n\t\tcell.cell :\n\t\tcell;\n}\n\nfunction _addClue(obj, clue) {\n\tobj[clue[0]] = clue[1];\n\n\treturn obj;\n}\n\nfunction _convertPuzzle(ipuz) {\n\tconst puzzle = new Puzzle({\n\t\tinfo: {\n\t\t\ttitle: ipuz.title,\n\t\t\tauthor: ipuz.author,\n\t\t\tcopyright: ipuz.copyright,\n\t\t\tpublisher: ipuz.publisher,\n\t\t\tdifficulty: ipuz.difficulty,\n\t\t\tintro: ipuz.intro,\n\t\t},\n\t\tgrid: ipuz.puzzle.map(\n\t\t\t(row) => row.map(\n\t\t\t\t(cell) => {\n\t\t\t\t\tif (cell === BLOCK_VALUE) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tisBlockCell: true\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tclueNumber: _getClueNumber(cell),\n\t\t\t\t\t\tbackgroundShape: get(cell, \"style.shapebg\")\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t)\n\t\t),\n\t\tclues: {\n\t\t\tacross: reduce(ipuz.clues.across,\n\t\t\t\t_addClue,\n\t\t\t\t{}\n\t\t\t),\n\t\t\tdown: reduce(ipuz.clues.down,\n\t\t\t\t_addClue,\n\t\t\t\t{}\n\t\t\t),\n\t\t}\n\t});\n\n\treturn puzzle;\n}\n\nfunction _validatePuzzle(puzzle) {\n\tconst errors = [];\n\n\tif (!puzzle.dimensions) {\n\t\terrors.push(\"Puzzle is missing 'dimensions' key\");\n\t}\n\n\tif (puzzle.puzzle) {\n\t\terrors.push(..._checkDimensions(puzzle));\n\t}\n\telse {\n\t\terrors.push(\"Puzzle is missing 'puzzle' key\");\n\t}\n\n\treturn errors.length === 0 ? undefined : errors;\n}\n\nfunction _parsePuzzle(puzzle) {\n\treturn new Promise(\n\t\t(resolve, reject) => {\n\t\t\tif (isObject(puzzle)) {\n\t\t\t\tresolve(puzzle);\n\t\t\t\treturn puzzle;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn reject(new Error(\"parse() expects either a path string or an object\"));\n\t\t\t}\n\t\t}\n\t).then(\n\t\t(puzzle) => {\n\t\t\tconst errors = _validatePuzzle(puzzle);\n\n\t\t\tif (errors !== undefined) {\n\t\t\t\tthrow new Error(`Invalid puzzle:\\n\\t${errors.join(\"\\n\\t\")}`);\n\t\t\t}\n\n\t\t\treturn _convertPuzzle(puzzle);\n\t\t}\n\t);\n}\n\n/**\n * Parser class for IPUZ-formatted puzzles\n */\nclass IPUZParser {\n\t/**\n\t * Parses a {@link module:xpuz/puzzle~Puzzle|Puzzle} from the input.\n\t *\n\t * @param {string|object} puzzle - the source to parse the puzzle from; if a string,\n\t *\tit is assumed to be a file path, if an object, it defines a Puzzle object.\n\t *\n\t * @returns {module:xpuz/puzzle~Puzzle} the parsed {@link module:xpuz/puzzle~Puzzle|Puzzle} object\n\t */\n\tparse(puzzle) {\n\t\treturn _parsePuzzle(puzzle);\n\t}\n}\n\nexports = module.exports = IPUZParser;\n"]}