{"version":3,"sources":["../../src/parsers/ipuz.js"],"names":["Promise","require","fs","readFile","promisify","max","get","isObject","isString","reduce","Puzzle","BLOCK_VALUE","_checkDimensions","puzzle","errors","maxCellWidth","length","numRows","dimensions","width","push","height","_getClueNumber","cell","_addClue","obj","clue","_convertPuzzle","ipuz","info","title","author","copyright","publisher","difficulty","intro","grid","map","row","isBlockCell","clueNumber","backgroundShape","clues","across","down","_validatePuzzle","_parsePuzzle","resolve","reject","then","fileContent","JSON","parse","toString","content","catch","ex","Error","message","join","IPUZParser","exports","module"],"mappings":"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","file":"ipuz.js","sourcesContent":["/**\n * IPUZ file parser.\n *\n * @module xpuz/parsers/ipuz\n */\n\nconst Promise         = require(\"bluebird\");\nconst fs              = require(\"fs\");\n// fs is stubbed out for browser builds\nconst readFile        = fs.readFile ? Promise.promisify(fs.readFile) : () => {};\nconst max             = require(\"lodash/max\");\nconst get             = require(\"lodash/get\");\nconst isObject        = require(\"lodash/isObject\");\nconst isString        = require(\"lodash/isString\");\nconst reduce          = require(\"lodash/reduce\");\nconst Puzzle          = require(\"../puzzle\");\n\nconst BLOCK_VALUE = \"#\";\n\nfunction _checkDimensions(puzzle) {\n\tconst errors = [];\n\n\tconst maxCellWidth = max(\n\t\tpuzzle.puzzle,\n\t\t\"length\"\n\t).length;\n\n\tconst numRows = puzzle.puzzle.length;\n\n\tif (maxCellWidth > puzzle.dimensions.width) {\n\t\terrors.push(`Too many puzzle cells (${maxCellWidth}) for puzzle width (${puzzle.dimensions.width})`);\n\t}\n\n\tif (numRows > puzzle.dimensions.height) {\n\t\terrors.push(`Too many puzzle cells (${numRows}) for puzzle height (${puzzle.dimensions.height})`);\n\t}\n\n\treturn errors;\n}\n\nfunction _getClueNumber(cell) {\n\treturn isObject(cell) ?\n\t\tcell.cell :\n\t\tcell;\n}\n\nfunction _addClue(obj, clue) {\n\tobj[clue[0]] = clue[1];\n\n\treturn obj;\n}\n\nfunction _convertPuzzle(ipuz) {\n\tconst puzzle = new Puzzle({\n\t\tinfo: {\n\t\t\ttitle: ipuz.title,\n\t\t\tauthor: ipuz.author,\n\t\t\tcopyright: ipuz.copyright,\n\t\t\tpublisher: ipuz.publisher,\n\t\t\tdifficulty: ipuz.difficulty,\n\t\t\tintro: ipuz.intro,\n\t\t},\n\t\tgrid: ipuz.puzzle.map(\n\t\t\t(row) => row.map(\n\t\t\t\t(cell) => {\n\t\t\t\t\tif (cell === BLOCK_VALUE) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tisBlockCell: true\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tclueNumber: _getClueNumber(cell),\n\t\t\t\t\t\tbackgroundShape: get(cell, \"style.shapebg\")\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t)\n\t\t),\n\t\tclues: {\n\t\t\tacross: reduce(ipuz.clues.across,\n\t\t\t\t_addClue,\n\t\t\t\t{}\n\t\t\t),\n\t\t\tdown: reduce(ipuz.clues.down,\n\t\t\t\t_addClue,\n\t\t\t\t{}\n\t\t\t),\n\t\t}\n\t});\n\n\treturn puzzle;\n}\n\nfunction _validatePuzzle(puzzle) {\n\tconst errors = [];\n\n\tif (!puzzle.dimensions) {\n\t\terrors.push(\"Puzzle is missing 'dimensions' key\");\n\t}\n\n\tif (puzzle.puzzle) {\n\t\terrors.push(..._checkDimensions(puzzle));\n\t}\n\telse {\n\t\terrors.push(\"Puzzle is missing 'puzzle' key\");\n\t}\n\n\treturn errors.length === 0 ? undefined : errors;\n}\n\nfunction _parsePuzzle(puzzle) {\n\treturn new Promise(\n\t\t(resolve, reject) => {\n\t\t\tif (isString(puzzle)) {\n\t\t\t\t// path to puzzle\n\t\t\t\treturn readFile(puzzle).then(\n\t\t\t\t\t(fileContent) => JSON.parse(fileContent.toString())\n\t\t\t\t).then(\n\t\t\t\t\t(content) => resolve(content)\n\t\t\t\t).catch(\n\t\t\t\t\t(ex) => {\n\t\t\t\t\t\treject(new Error(`Unable to read IPUZ puzzle from file ${puzzle}: ${ex.message}`));\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t\telse if (isObject(puzzle)) {\n\t\t\t\tresolve(puzzle);\n\t\t\t\treturn puzzle;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn reject(new Error(\"parse() expects either a path string or an object\"));\n\t\t\t}\n\t\t}\n\t).then(\n\t\t(puzzle) => {\n\t\t\tconst errors = _validatePuzzle(puzzle);\n\n\t\t\tif (errors !== undefined) {\n\t\t\t\tthrow new Error(`Invalid puzzle:\\n\\t${errors.join(\"\\n\\t\")}`);\n\t\t\t}\n\n\t\t\treturn _convertPuzzle(puzzle);\n\t\t}\n\t);\n}\n\n/**\n * Parser class for IPUZ-formatted puzzles\n */\nclass IPUZParser {\n\t/**\n\t * Parses a {@link module:xpuz/puzzle~Puzzle|Puzzle} from the input.\n\t *\n\t * @param {string|object} puzzle - the source to parse the puzzle from; if a string,\n\t *\tit is assumed to be a file path, if an object, it defines a Puzzle object.\n\t *\n\t * @returns {module:xpuz/puzzle~Puzzle} the parsed {@link module:xpuz/puzzle~Puzzle|Puzzle} object\n\t */\n\tparse(puzzle) {\n\t\treturn _parsePuzzle(puzzle);\n\t}\n}\n\nexports = module.exports = IPUZParser;\n"]}