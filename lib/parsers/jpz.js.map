{"version":3,"sources":["../../src/parsers/jpz.js"],"names":["isString","require","isObject","Promise","fs","readFile","promisify","Puzzle","_parsePuzzle","puzzle","resolve","reject","then","fileContent","toString","catch","ex","Error","message","JPZParser","exports","module"],"mappings":";;;;AAAA;;;;;;;AAOA,IAAMA,WAAkBC,QAAQ,iBAAR,CAAxB;AACA,IAAMC,WAAkBD,QAAQ,iBAAR,CAAxB;AACA,IAAME,UAAkBF,QAAQ,UAAR,CAAxB;AACA,IAAMG,KAAkBH,QAAQ,IAAR,CAAxB;AACA;AACA,IAAMI,WAAkBD,GAAGC,QAAH,GAAcF,QAAQG,SAAR,CAAkBF,GAAGC,QAArB,CAAd,GAA+C,YAAM,CAAE,CAA/E;AACA,IAAME,SAAkBN,QAAQ,WAAR,CAAxB;;AAGA,SAASO,YAAT,CAAsBC,MAAtB,EAA8B;AAC7B,QAAO,IAAIN,OAAJ,CACN,UAACO,OAAD,EAAUC,MAAV,EAAqB;AACpB,MAAIX,SAASS,MAAT,CAAJ,EAAsB;AACrB;AACA,UAAOJ,SAASI,MAAT,EAAiBG,IAAjB,CACN,UAACC,WAAD;AAAA,WAAiBH,QAAQ,IAAIH,MAAJ,CAAWM,YAAYC,QAAZ,EAAX,CAAR,CAAjB;AAAA,IADM,EAELC,KAFK,CAGN,UAACC,EAAD,EAAQ;AACPL,WAAO,IAAIM,KAAJ,CAAU,yCAChBR,MADgB,GACP,IADO,GACAO,GAAGE,OADb,CAAP;AAEA,IANK,CAAP;AAQA,GAVD,MAWK,IAAIhB,SAASO,MAAT,CAAJ,EAAsB;AAC1B,UAAOC,QAAQ,IAAIH,MAAJ,CAAWE,MAAX,CAAR,CAAP;AACA,GAFI,MAGA;AACJ,UAAOE,OAAO,IAAIM,KAAJ,CAAU,mDAAV,CAAP,CAAP;AACA;AACD,EAnBK,CAAP;AAqBA;;AAED;;;;IAGME,S;;;;;;;;AACL;;;;;;;;;wBASMV,M,EAAQ;AACb,UAAOD,aAAaC,MAAb,CAAP;AACA;;;;;;AAGFW,UAAUC,OAAOD,OAAP,GAAiBD,SAA3B","file":"jpz.js","sourcesContent":["/**\n * JPZ Parser\n *\n * @description Parses .jpz formatted puzzles (NOT CURRENTLY IMPLEMENTED)\n * @module xpuz/parsers/jpz\n */\n\nconst isString        = require(\"lodash/isString\");\nconst isObject        = require(\"lodash/isObject\");\nconst Promise         = require(\"bluebird\");\nconst fs              = require(\"fs\");\n// fs is stubbed out for browser builds\nconst readFile        = fs.readFile ? Promise.promisify(fs.readFile) : () => {};\nconst Puzzle          = require(\"../puzzle\");\n\n\nfunction _parsePuzzle(puzzle) {\n\treturn new Promise(\n\t\t(resolve, reject) => {\n\t\t\tif (isString(puzzle)) {\n\t\t\t\t// path to puzzle\n\t\t\t\treturn readFile(puzzle).then(\n\t\t\t\t\t(fileContent) => resolve(new Puzzle(fileContent.toString()))\n\t\t\t\t).catch(\n\t\t\t\t\t(ex) => {\n\t\t\t\t\t\treject(new Error(\"Unable to read JPZ puzzle from file \" +\n\t\t\t\t\t\t\tpuzzle + \": \" + ex.message));\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t\telse if (isObject(puzzle)) {\n\t\t\t\treturn resolve(new Puzzle(puzzle));\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn reject(new Error(\"parse() expects either a path string or an object\"));\n\t\t\t}\n\t\t}\n\t);\n}\n\n/**\n * JPZ parser class\n */\nclass JPZParser {\n\t/**\n\t * Parses a {@link module:xpuz/puzzle~Puzzle} from the input\n\t *\n\t * @param {string|object} puzzle - the source to parse the puzzle from; if a string,\n\t *\tit is assumed to be a file path, if an object, it defines a Puzzle object\n\t *\n\t * @return {external:Promise<module:xpuz/puzzle~Puzzle>} a promise that resolves with\n\t *\tthe parsed puzzle object\n\t */\n\tparse(puzzle) {\n\t\treturn _parsePuzzle(puzzle);\n\t}\n}\n\nexports = module.exports = JPZParser;\n"]}