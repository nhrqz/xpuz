{"version":3,"sources":["../src/puzzle-mixin.js"],"names":["hashIt","require","get","set","size","PuzzleMixin","constructor","equalityTest","getter","setter","sizeOf","constructorName","name","findContainingClues","grid","width","height","rowIndex","columnIndex","containingClues","clueNumber","across","down","i","hasClueNumber","Object","defineProperties","prototype","equals","writable","configurable","value","other","clues","userSolution","info","extensions","hashCode","toString","Symbol","toStringTag","updateGrid","processGrid","updateCell","cell","enumerable","args","cellClueNumber","exports","module"],"mappings":"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","file":"puzzle-mixin.js","sourcesContent":["const hashIt = require(\"hash-it\");\nconst get    = require(\"lodash/get\");\nconst set    = require(\"lodash/set\");\nconst size   = require(\"lodash/size\");\n\n/**\n * Provides common functionality for {@link xpuz.ImmutablePuzzle} and {@link xpuz.Puzzle} classes.\n *\n * @mixin\n * @memberof xpuz\n *\n * @return {void}\n */\nfunction PuzzleMixin({ constructor, equalityTest, getter = get, setter = set, sizeOf = size }) {\n\tconst constructorName = constructor.name;\n\n\t/**\n\t * Finds which across and down clues a grid cell is a member of.\n\t *\n\t * @private\n\t *\n\t * @param {object} args - the function arguments\n\t * @param {Types.Grid|Types.ImmutableGrid} args.grid - the grid containing the cell\n\t * @param {number} args.width - the width of the grid (this is here just so that it doesn't have\n\t *\tto calculate it every time this is called)\n\t * @param {number} args.height - the height of the grid (this is here just so that it doesn't have\n\t *\tto calculate it every time this is called)\n\t * @param {number} args.rowIndex - the index of the row on which the cell occurs\n\t * @param {number} args.columnIndex - the index of the column on which the cell occurs\n\t *\n\t * @return {{across: ?number, down: ?number}} the clue numbers for the clues that contain this cell\n\t *\t(one or both of `across` and `down` keys may be populated)\n\t */\n\tfunction findContainingClues({ grid, width, height, rowIndex, columnIndex }) {\n\t\tconst containingClues = {};\n\n\t\tconst clueNumber = getter(grid, [rowIndex, columnIndex, \"clueNumber\"]);\n\n\t\tif (clueNumber !== undefined) {\n\t\t\t// This cell is a clue number cell--it defines either\n\t\t\t// its across clue number or its down clue number (or\n\t\t\t// both)\n\n\t\t\tif (\n\t\t\t\t// This is either at the left edge of the puzzle or\n\t\t\t\t// is bounded on the left by a block cell. This clue\n\t\t\t\t// number defines (at least) the cell's across clue number\n\t\t\t\t(columnIndex === 0 || getter(grid, [rowIndex, columnIndex - 1, \"isBlockCell\"])) &&\n\t\t\t\t// There is at least one fillable cell to the right\n\t\t\t\t(columnIndex < width - 1 && !getter(grid, [rowIndex, columnIndex + 1, \"isBlockCell\"]))\n\t\t\t) {\n\t\t\t\tcontainingClues.across = clueNumber;\n\t\t\t}\n\t\t\telse if (\n\t\t\t\t// There is at least one fillable cell below this\n\t\t\t\trowIndex < height - 1 && !getter(grid, [rowIndex + 1, columnIndex, \"isBlockCell\"])\n\t\t\t){\n\t\t\t\t// At least one cell exists to the left of this cell; this\n\t\t\t\t// is not an across clue number. It must be a down clue number.\n\t\t\t\tcontainingClues.down = clueNumber;\n\t\t\t}\n\t\t}\n\n\t\tif (!containingClues.across) {\n\t\t\t// Haven't found the across clue number yet.\n\t\t\t// Look to the left until we find a block cell or the edge of\n\t\t\t// the puzzle\n\t\t\tif (\n\t\t\t\t// At the left edge of the puzzle and there's a clue number\n\t\t\t\t(columnIndex === 0 && clueNumber !== undefined) &&\n\t\t\t\t// There is at least one fillable cell to the right\n\t\t\t\t!getter(grid, [rowIndex, columnIndex + 1, \"isBlockCell\"])\n\t\t\t) {\n\t\t\t\tcontainingClues.across = clueNumber;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (let i = columnIndex - 1; i >= 0; i--) {\n\t\t\t\t\tif (getter(grid, [rowIndex, i, \"isBlockCell\"])) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (\n\t\t\t\t\t\t// There is at least one fillable cell to the right\n\t\t\t\t\t\ti < width - 1 && !getter(grid, [rowIndex, i + 1, \"isBlockCell\"])\n\t\t\t\t\t) {\n\t\t\t\t\t\tcontainingClues.across = getter(grid, [rowIndex, i, \"clueNumber\"]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!containingClues.down) {\n\t\t\t// Look at cells in other rows at the same index until we find a\n\t\t\t// cell with a clue number\n\t\t\tif (\n\t\t\t\t// At the top of the puzzle and there is a clue number\n\t\t\t\t(rowIndex === 0 && clueNumber !== undefined) &&\n\t\t\t\t// There is at least one fillable cell below it\n\t\t\t\t!getter(grid, [rowIndex + 1, columnIndex, \"isBlockCell\"])\n\t\t\t) {\n\t\t\t\tcontainingClues.down = clueNumber;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (let i = rowIndex; i >= 0; i--) {\n\t\t\t\t\tif (getter(grid, [i, columnIndex, \"isBlockCell\"])) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (\n\t\t\t\t\t\t// There is at least one fillable cell below it\n\t\t\t\t\t\ti < height - 1 && !getter(grid, [i + 1, columnIndex, \"isBlockCell\"])\n\t\t\t\t\t) {\n\t\t\t\t\t\tcontainingClues.down = getter(grid, [i, columnIndex, \"clueNumber\"]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn containingClues;\n\t}\n\n\t/**\n\t * Determines whether a cell in the grid is at the start of a down or across clue (or\n\t * both), and thus should be given a clue number.\n\t *\n\t * @private\n\t *\n\t * @param {object} args - the function arguments\n\t * @param {Types.Grid|Types.ImmutableGrid} args.grid - the grid containing the cell\n\t * @param {number} args.width - the width of the grid (this is here just so that it doesn't have\n\t *\tto calculate it every time this is called)\n\t * @param {number} args.height - the height of the grid (this is here just so that it doesn't have\n\t *\tto calculate it every time this is called)\n\t * @param {number} args.rowIndex - the index of the row on which the cell occurs\n\t * @param {number} args.columnIndex - the index of the column on which the cell occurs\n\t *\n\t * @return {boolean} whether or not the specified cell should be given a clue number\n\t */\n\tfunction hasClueNumber({ grid, width, height, rowIndex, columnIndex }) {\n\t\tif (getter(grid, [rowIndex, columnIndex, \"isBlockCell\"])) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (\n\t\t\t(columnIndex === 0 || getter(grid, [rowIndex, columnIndex - 1, \"isBlockCell\"])) &&\n\t\t\t(columnIndex + 1 < width && !getter(grid, [rowIndex, columnIndex + 1, \"isBlockCell\"]))\n\t\t) {\n\t\t\t// This cell is adjacent to the puzzle edge or a block cell on the left,\n\t\t\t// and has at least one input cell to its right--this cell starts an across clue\n\t\t\treturn true;\n\t\t}\n\n\t\tif (\n\t\t\t(rowIndex === 0 || getter(grid, [rowIndex - 1, columnIndex, \"isBlockCell\"])) &&\n\t\t\t(rowIndex + 1 < height && !getter(grid, [rowIndex + 1, columnIndex, \"isBlockCell\"]))\n\t\t) {\n\t\t\t// This cell is adjacent to the puzzle edge or a block cell on the top,\n\t\t\t// and has at least one input cell below it--this cell starts a down clue\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tObject.defineProperties(\n\t\tconstructor.prototype,\n\t\t{\n\t\t\t/**\n\t\t\t * Determines whether this object is equivalent to another object\n\t\t\t *\n\t\t\t * @method\n\t\t\t * @instance\n\t\t\t * @memberof xpuz.PuzzleMixin\n\t\t\t *\n\t\t\t * @param {*} other - the object to compare against\n\t\t\t *\n\t\t\t * @return {boolean} whether or not the other object is equal to this\n\t\t\t */\n\t\t\tequals: {\n\t\t\t\twritable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: function equals(other) {\n\t\t\t\t\tif (!(other instanceof constructor)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn equalityTest(this.grid, other.grid) &&\n\t\t\t\t\t\tequalityTest(this.clues, other.clues) &&\n\t\t\t\t\t\tequalityTest(this.userSolution, other.userSolution) &&\n\t\t\t\t\t\tequalityTest(this.info, other.info) &&\n\t\t\t\t\t\tequalityTest(this.extensions, other.extensions);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Returns a hash code integer for this object.\n\t\t\t *\n\t\t\t * @method\n\t\t\t * @instance\n\t\t\t * @memberof xpuz.PuzzleMixin\n\t\t\t *\n\t\t\t * @return {number} the object's hash code\n\t\t\t */\n\t\t\thashCode: {\n\t\t\t\twritable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: function hashCode() {\n\t\t\t\t\treturn hashIt(this);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Returns a string representation of this object.\n\t\t\t *\n\t\t\t * @method\n\t\t\t * @instance\n\t\t\t * @memberof xpuz.PuzzleMixin\n\t\t\t *\n\t\t\t * @return {string} string representation of this object\n\t\t\t */\n\t\t\ttoString: {\n\t\t\t\twritable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: function toString() {\n\t\t\t\t\treturn constructorName;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Returns a string representation of this object.\n\t\t\t *\n\t\t\t * @member {string} @@toStringTag\n\t\t\t * @instance\n\t\t\t * @readonly\n\t\t\t * @memberof xpuz.PuzzleMixin\n\t\t\t *\n\t\t\t * @return {string} string representation of this object\n\t\t\t */\n\t\t\t[Symbol.toStringTag]: {\n\t\t\t\tconfigurable: true,\n\t\t\t\tget() {\n\t\t\t\t\treturn constructorName;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Updates the cells of the grid to have accurate clue numbering and `containingClues` properties.\n\t\t\t *\n\t\t\t * @method\n\t\t\t * @instance\n\t\t\t * @memberof xpuz.PuzzleMixin\n\t\t\t *\n\t\t\t * @param {Types.Grid|Types.ImmutableGrid} [grid=this.grid] - the grid to update and set as the puzzle's grid\n\t\t\t *\n\t\t\t * @return {Puzzle|ImmutablePuzzle} the puzzle, with the updated cell information (return type is whatever\n\t\t\t *\ttype `this` is)\n\t\t\t */\n\t\t\tupdateGrid: {\n\t\t\t\twritable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: function updateGrid(grid = this.grid) {\n\t\t\t\t\treturn setter(this, [\"grid\"], constructor.processGrid(grid));\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Sets the value of the specified cell and ensures that all cell information is kept up-to-date.\n\t\t\t *\n\t\t\t * @method\n\t\t\t * @instance\n\t\t\t * @memberof xpuz.PuzzleMixin\n\t\t\t *\n\t\t\t * @param {number} columnIndex - the column index of the cell to set\n\t\t\t * @param {number} rowIndex - the row index of the cell to set\n\t\t\t * @param {Types.GridCell|external:Immutable.Map<Types.GridCell>} - the cell information to set (this\n\t\t\t *\treplaces the existing cell information)\n\t\t\t *\n\t\t\t * @return {Puzzle|ImmutablePuzzle} the puzzle, with the updated cell information (return type is whatever\n\t\t\t *\ttype `this` is)\n\t\t\t */\n\t\t\tupdateCell: {\n\t\t\t\twritable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: function updateCell(columnIndex, rowIndex, cell) {\n\t\t\t\t\tconst grid = setter(this.grid, [rowIndex, columnIndex], cell);\n\n\t\t\t\t\treturn this.updateGrid(grid);\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\t);\n\n\tObject.defineProperties(\n\t\tconstructor,\n\t\t{\n\t\t\t/**\n\t\t\t * Updates the specified grid with the correct cell information (clue numbers, etc.)\n\t\t\t *\n\t\t\t * @function\n\t\t\t * @memberof xpuz.PuzzleMixin\n\t\t\t *\n\t\t\t * @param {Types.Grid|Types.ImmutableGrid} grid - the\n\t\t\t *\tgrid to update\n\t\t\t *\n\t\t\t * @return {Puzzle|ImmutablePuzzle} the puzzle, with the updated cell information (return type is whatever\n\t\t\t *\ttype `grid` is)\n\t\t\t */\n\t\t\tprocessGrid: {\n\t\t\t\twritable: true,\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: function processGrid(grid) {\n\t\t\t\t\tconst height = sizeOf(grid);\n\t\t\t\t\tconst width = sizeOf(getter(grid, [0]));\n\t\t\t\t\tlet clueNumber = 0;\n\n\t\t\t\t\tfor (let rowIndex = 0; rowIndex < height; rowIndex++) {\n\t\t\t\t\t\tfor (let columnIndex = 0; columnIndex < width; columnIndex++) {\n\t\t\t\t\t\t\tif (getter(grid, [rowIndex, columnIndex, \"isBlockCell\"])) {\n\t\t\t\t\t\t\t\tsetter(grid, [rowIndex, columnIndex, \"clueNumber\"], undefined);\n\t\t\t\t\t\t\t\tsetter(grid, [rowIndex, columnIndex, \"containingClues\"], undefined);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tconst args = {\n\t\t\t\t\t\t\t\tgrid,\n\t\t\t\t\t\t\t\twidth,\n\t\t\t\t\t\t\t\theight,\n\t\t\t\t\t\t\t\trowIndex,\n\t\t\t\t\t\t\t\tcolumnIndex,\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tconst cellClueNumber = hasClueNumber(args) ?\n\t\t\t\t\t\t\t\t++clueNumber :\n\t\t\t\t\t\t\t\tundefined;\n\n\t\t\t\t\t\t\tsetter(grid, [rowIndex, columnIndex, \"clueNumber\"], cellClueNumber);\n\n\t\t\t\t\t\t\tsetter(grid, [rowIndex, columnIndex, \"containingClues\"], findContainingClues(args));\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn grid;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t);\n}\n\nexports = module.exports = PuzzleMixin;\n"]}