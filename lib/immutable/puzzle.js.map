{"version":3,"sources":["../../src/immutable/puzzle.js"],"names":["require","List","Map","OrderedMap","Record","is","Collection","fromJS","PuzzleMixin","infoSchema","title","author","publisher","copyright","difficulty","intro","PuzzleInfo","schema","grid","clues","across","down","userSolution","info","extensions","ImmutablePuzzle","processGrid","args","map","row","cell","get","isMap","direction","Object","keys","Number","sort","clueNumber","constructor","equalityTest","getter","obj","path","getIn","setter","value","setIn","sizeOf","size","oldProcessGrid","withMutations","gridWithMutations","exports","module"],"mappings":"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","file":"puzzle.js","sourcesContent":["const {\n\tList,\n\tMap,\n\tOrderedMap,\n\tRecord,\n\tis,\n\tCollection,\n\tfromJS\n}                 = require(\"immutable\");\nconst PuzzleMixin = require(\"../puzzle-mixin\");\n\nconst infoSchema = {\n\ttitle: \"\",\n\tauthor: \"\",\n\tpublisher: \"\",\n\tcopyright: \"\",\n\tdifficulty: \"\",\n\tintro: \"\",\n};\n\nclass PuzzleInfo extends Record(infoSchema, \"PuzzleInfo\") {}\n\nconst schema = {\n\tgrid: List(),\n\tclues: Map({\n\t\tacross: OrderedMap(),\n\t\tdown: OrderedMap(),\n\t}),\n\tuserSolution: List(),\n\tinfo: new PuzzleInfo(),\n\textensions: Map(),\n};\n\n/**\n * Represents an immutable version of {@link xpuz.Puzzle|Puzzle}.\n *\n * @extends external:Immutable.Record\n * @memberof xpuz\n *\n * @mixes xpuz.PuzzleMixin\n */\nclass ImmutablePuzzle extends Record(schema, \"ImmutablePuzzle\") {\n\t/**\n\t * @param {object} args - the constructor arguments\n\t * @param {Types.ImmutableGrid|Types.Grid} args.grid - the grid for the puzzle\n\t * @param {{across: object, down: object}|external:Immutable.Map<{across: external:Immutable.Map, down: external:Immutable.Map}>} args.clues - the\n\t *\tpuzzle clues\n\t * @param {Array<string[]>|external:Immutable.List<external:Immutable.List<string>>} [args.userSolution] - the guesses that the user\n\t *\thas entered for this puzzle, as a two-dimensional array of array of strings with the same dimensions as the `grid` where\n\t *\teach cell is either a string with the user's input or `null` if it corresponds to a block cell in the grid\n\t * @param {xpuz.PuzzleInfo|object} [args.info] - information about the puzzle\n\t * @param {object} [args.extensions] - a store of extra, possibly implementation-dependent information about the puzzle (such as timer information)\n\t */\n\tconstructor({\n\t\tgrid,\n\t\tclues,\n\t\tuserSolution,\n\t\tinfo,\n\t\textensions\n\t}) {\n\t\tif (!(info instanceof PuzzleInfo)) {\n\t\t\tinfo = new PuzzleInfo(info);\n\t\t}\n\n\t\tgrid = grid ? ImmutablePuzzle.processGrid(fromJS(grid)) : List();\n\n\t\tconst args = {\n\t\t\tinfo,\n\t\t\tgrid,\n\t\t\tuserSolution: userSolution ?\n\t\t\t\tfromJS(userSolution) :\n\t\t\t\tgrid.map(\n\t\t\t\t\t(row) => row.map(\n\t\t\t\t\t\t(cell) => cell.get(\"isBlockCell\") ? null : \"\"\n\t\t\t\t\t)\n\t\t\t\t),\n\t\t};\n\n\t\tif (clues) {\n\t\t\targs.clues = Map.isMap(clues) ?\n\t\t\t\tclues :\n\t\t\t\tMap(\n\t\t\t\t\t[\"across\", \"down\"].map(\n\t\t\t\t\t\t(direction) => [\n\t\t\t\t\t\t\tdirection,\n\t\t\t\t\t\t\tOrderedMap(\n\t\t\t\t\t\t\t\tObject.keys(clues[direction]).map(Number).sort().map(\n\t\t\t\t\t\t\t\t\t(clueNumber) => [clueNumber, clues[direction][clueNumber]]\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t]\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t}\n\n\t\tif (extensions) {\n\t\t\targs.extensions = fromJS(extensions);\n\t\t}\n\n\t\tsuper(args);\n\t}\n\n\t/**\n\t * The grid for this puzzle\n\t *\n\t * @member {Types.ImmutableGrid} grid\n\t * @instance\n\t */\n}\n\nPuzzleMixin({\n\tconstructor: ImmutablePuzzle,\n\tequalityTest: is,\n\tgetter: (obj, path) => obj.getIn(path),\n\tsetter: (obj, path, value) => obj.setIn(path, value instanceof Collection ? value : fromJS(value)),\n\tsizeOf: (obj) => obj.size,\n});\n\nconst oldProcessGrid = ImmutablePuzzle.processGrid;\n\nImmutablePuzzle.processGrid = function processGrid(grid) {\n\treturn grid.withMutations(\n\t\t(gridWithMutations) => oldProcessGrid(gridWithMutations)\n\t);\n};\n\nexports = module.exports = ImmutablePuzzle;\n"]}