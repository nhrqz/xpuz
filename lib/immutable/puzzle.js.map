{"version":3,"sources":["../../src/immutable/puzzle.js"],"names":["require","List","Map","OrderedMap","Record","is","Collection","fromJS","PuzzleMixin","infoSchema","title","author","publisher","copyright","difficulty","intro","formatExtra","PuzzleInfo","schema","grid","clues","across","down","userSolution","info","extensions","ImmutablePuzzle","processGrid","args","map","row","cell","get","isMap","direction","Object","keys","sort","a","b","clueNumber","Number","constructor","equalityTest","getter","obj","path","getIn","setter","value","setIn","sizeOf","size","oldProcessGrid","withMutations","gridWithMutations","exports","module"],"mappings":"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","file":"puzzle.js","sourcesContent":["const {\n\tList,\n\tMap,\n\tOrderedMap,\n\tRecord,\n\tis,\n\tCollection,\n\tfromJS\n}                 = require(\"immutable\");\nconst PuzzleMixin = require(\"../puzzle-mixin\");\n\nconst infoSchema = {\n\ttitle: \"\",\n\tauthor: \"\",\n\tpublisher: \"\",\n\tcopyright: \"\",\n\tdifficulty: \"\",\n\tintro: \"\",\n\tformatExtra: undefined,\n};\n\nclass PuzzleInfo extends Record(infoSchema, \"PuzzleInfo\") {}\n\nconst schema = {\n\tgrid: List(),\n\tclues: Map({\n\t\tacross: OrderedMap(),\n\t\tdown: OrderedMap(),\n\t}),\n\tuserSolution: List(),\n\tinfo: new PuzzleInfo(),\n\textensions: Map(),\n};\n\n/**\n * Represents an immutable version of {@link xpuz.Puzzle|Puzzle}.\n *\n * @extends external:Immutable.Record\n * @memberof xpuz\n *\n * @mixes xpuz.PuzzleMixin\n */\nclass ImmutablePuzzle extends Record(schema, \"ImmutablePuzzle\") {\n\t/**\n\t * @param {object} args - the constructor arguments\n\t * @param {Types.ImmutableGrid|Types.Grid} args.grid - the grid for the puzzle\n\t * @param {{across: object, down: object}|external:Immutable.Map<{across: external:Immutable.Map, down: external:Immutable.Map}>} args.clues - the\n\t *\tpuzzle clues\n\t * @param {Array<string[]>|external:Immutable.List<external:Immutable.List<string>>} [args.userSolution] - the guesses that the user\n\t *\thas entered for this puzzle, as a two-dimensional array of array of strings with the same dimensions as the `grid` where\n\t *\teach cell is either a string with the user's input or `null` if it corresponds to a block cell in the grid\n\t * @param {xpuz.PuzzleInfo|object} [args.info] - information about the puzzle\n\t * @param {object} [args.extensions] - a store of extra, possibly implementation-dependent information about the puzzle (such as timer information)\n\t */\n\tconstructor({\n\t\tgrid,\n\t\tclues,\n\t\tuserSolution,\n\t\tinfo,\n\t\textensions\n\t}) {\n\t\tif (!(info instanceof PuzzleInfo)) {\n\t\t\tinfo = new PuzzleInfo(info);\n\t\t}\n\n\t\tgrid = grid ? ImmutablePuzzle.processGrid(fromJS(grid)) : List();\n\n\t\tconst args = {\n\t\t\tinfo,\n\t\t\tgrid,\n\t\t\tuserSolution: userSolution ?\n\t\t\t\tfromJS(userSolution) :\n\t\t\t\tgrid.map(\n\t\t\t\t\t(row) => row.map(\n\t\t\t\t\t\t(cell) => cell.get(\"isBlockCell\") ? null : \"\"\n\t\t\t\t\t)\n\t\t\t\t),\n\t\t};\n\n\t\tif (clues) {\n\t\t\targs.clues = Map.isMap(clues) ?\n\t\t\t\tclues :\n\t\t\t\tMap(\n\t\t\t\t\t[\"across\", \"down\"].map(\n\t\t\t\t\t\t(direction) => [\n\t\t\t\t\t\t\tdirection,\n\t\t\t\t\t\t\tOrderedMap(\n\t\t\t\t\t\t\t\tObject.keys(clues[direction]).sort((a, b) => a - b).map(\n\t\t\t\t\t\t\t\t\t(clueNumber) => [Number(clueNumber), clues[direction][clueNumber]]\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t]\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t}\n\n\t\tif (extensions) {\n\t\t\targs.extensions = fromJS(extensions);\n\t\t}\n\n\t\tsuper(args);\n\t}\n\n\t/**\n\t * The grid for this puzzle\n\t *\n\t * @member {Types.ImmutableGrid} grid\n\t * @instance\n\t */\n}\n\nPuzzleMixin({\n\tconstructor: ImmutablePuzzle,\n\tequalityTest: is,\n\tgetter: (obj, path) => obj.getIn(path),\n\tsetter: (obj, path, value) => obj.setIn(path, value instanceof Collection ? value : fromJS(value)),\n\tsizeOf: (obj) => obj.size,\n});\n\nconst oldProcessGrid = ImmutablePuzzle.processGrid;\n\nImmutablePuzzle.processGrid = function processGrid(grid) {\n\treturn grid.withMutations(\n\t\t(gridWithMutations) => oldProcessGrid(gridWithMutations)\n\t);\n};\n\nexports = module.exports = ImmutablePuzzle;\n"]}